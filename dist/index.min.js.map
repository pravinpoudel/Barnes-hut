{"version":3,"sources":["index.js"],"names":["Node","index","x","y","_classCallCheck","this","ctx","beginPath","strokeStyle","rect","stroke","Rectangle","w","h","node","WIDTH","HEIGHT","Quadtree","boundary","CoM","mass","SE","SW","NE","isDivided","nodes","se","sw","ne","nw","NW","length","push","existingNode","insert","partition","totalX","totalY","findMaxRange","maxX","maxY","Infinity","minX","minY","i","isNaN","console","distance","point1","point2","Math","sqrt","pow","calRepDisplacement","forceRepulsive","displacement","node1","d","sleep","setTimeout","Promise","resolve","ms","myCanvas","document","getElementById","getContext","qt","nodes2","initializeNodesRandomly","n","random","floor","theta","count","kSquare","k","iterationCount","_boundary","j","displacement2","BH","regeneratorRuntime","async","_context","prev","next","awrap","clearRect","width","height","time","timeEnd","toVisit","qd","pop","isNotSame","stop","log"],"mappings":"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","file":"index.min.js","sourcesContent":["class Node {\r\n  constructor(index, x, y) {\r\n    this.index = index;\r\n    this.x = x;\r\n    this.y = y;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = \"#FF0000\";\r\n    ctx.rect(x, y, 1, 1);\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nclass Rectangle {\r\n  constructor(x, y, w, h) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.w = w;\r\n    this.h = h;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = \"#000000\";\r\n    ctx.rect(x - w, y - h, 2 * w, 2 * h);\r\n    ctx.stroke();\r\n  }\r\n\r\n  bound(node) {\r\n    if (this.x + this.w == WIDTH) {\r\n      return (\r\n        node.x >= this.x - this.w &&\r\n        node.x <= this.x + this.w &&\r\n        node.y >= this.y - this.h &&\r\n        node.y < this.y + this.h\r\n      );\r\n    }\r\n\r\n    if (this.y + this.h == HEIGHT) {\r\n      return (\r\n        node.x >= this.x - this.w &&\r\n        node.x < this.x + this.w &&\r\n        node.y >= this.y - this.h &&\r\n        node.y <= this.y + this.h\r\n      );\r\n    } else {\r\n      return (\r\n        node.x >= this.x - this.w &&\r\n        node.x < this.x + this.w &&\r\n        node.y >= this.y - this.h &&\r\n        node.y < this.y + this.h\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nclass Quadtree {\r\n  constructor(boundary) {\r\n    this.boundary = boundary;\r\n    this.CoM = {\r\n      x: null,\r\n      y: null,\r\n    };\r\n    this.mass = 0;\r\n    this.NE = null;\r\n    this.NW = null;\r\n    this.SE = null;\r\n    this.SW = null;\r\n\r\n    this.isDivided = false;\r\n    this.nodes = [];\r\n  }\r\n\r\n  partition() {\r\n    let x = this.boundary.x;\r\n    let y = this.boundary.y;\r\n    let w = this.boundary.w;\r\n    let h = this.boundary.h;\r\n\r\n    let se = new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2);\r\n    let sw = new Rectangle(x - w / 2, y + h / 2, w / 2, h / 2);\r\n    let ne = new Rectangle(x + w / 2, y - h / 2, w / 2, h / 2);\r\n    let nw = new Rectangle(x - w / 2, y - h / 2, w / 2, h / 2);\r\n\r\n    this.NW = new Quadtree(nw);\r\n    this.NE = new Quadtree(ne);\r\n    this.SW = new Quadtree(sw);\r\n    this.SE = new Quadtree(se);\r\n    this.isDivided = true;\r\n  }\r\n\r\n  insert(node) {\r\n    if (!this.boundary.bound(node)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.nodes.length < 1 && !this.isDivided) {\r\n      //update center of mass\r\n      //update mass of the tree node\r\n      this.mass++;\r\n      this.CoM = {\r\n        x: node.x,\r\n        y: node.y,\r\n      };\r\n      this.nodes.push(node);\r\n      return true;\r\n    } else {\r\n      if (!this.isDivided) {\r\n        this.partition();\r\n        this.isDivided = true;\r\n        let existingNode = this.nodes[0];\r\n        this.nodes = [];\r\n        this.mass = 0;\r\n        this.NW.insert(existingNode) ||\r\n          this.NE.insert(existingNode) ||\r\n          this.SW.insert(existingNode) ||\r\n          this.SE.insert(existingNode);\r\n      }\r\n      let totalX = this.mass * this.CoM.x + node.x;\r\n      let totalY = this.mass * this.CoM.y + node.y;\r\n      this.mass++;\r\n      this.CoM.x = totalX / this.mass;\r\n      this.CoM.y = totalY / this.mass;\r\n\r\n      return (\r\n        this.NW.insert(node) ||\r\n        this.NE.insert(node) ||\r\n        this.SW.insert(node) ||\r\n        this.SE.insert(node)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n//we dont need to find max because we are limmiting the position in force calculation\r\nfunction findMaxRange(nodes) {\r\n  let maxX = -Infinity,\r\n    maxY = -Infinity,\r\n    minX = Infinity,\r\n    minY = Infinity;\r\n\r\n  let x, y;\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    if (!(isNaN((x = +nodes[i].x)) && isNaN((y = +nodes[i].y)))) {\r\n      if (x > maxX) maxX = x;\r\n      if (x < minX) minX = x;\r\n      if (y > maxY) maxY = y;\r\n      if (y < minY) minY = y;\r\n    }\r\n    //create a rectangle with this width and height and create a tree likewise\r\n    else {\r\n      console.warn(`position of point at index ${i} is not valid number`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction distance(point1, point2) {\r\n  return Math.sqrt(\r\n    Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2)\r\n  );\r\n}\r\n\r\nfunction calRepDisplacement(node1, CoM, mass) {\r\n  let displacement = {};\r\n  let d = distance(node1, CoM);\r\n  let forceRepulsive = kSquare / d;\r\n  displacement.x = ((node1.x - CoM.x) / d) * forceRepulsive * mass;\r\n  displacement.y = ((node1.y - CoM.y) / d) * forceRepulsive * mass;\r\n  return displacement;\r\n}\r\n\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nlet myCanvas = document.getElementById(\"draw\");\r\nlet ctx = myCanvas.getContext(\"2d\");\r\n\r\nconst WIDTH = 1024;\r\nconst HEIGHT = 900;\r\nlet boundary = new Rectangle(WIDTH / 2, HEIGHT / 2, WIDTH / 2, HEIGHT / 2);\r\nlet qt = new Quadtree(boundary);\r\nlet nodes = [];\r\nlet nodes2 = [];\r\n\r\nfunction initializeNodesRandomly(n) {\r\n  nodes = [];\r\n  nodes2 = [];\r\n  for (let i = 0; i < n; i++) {\r\n    let node = new Node(\r\n      i,\r\n      Math.floor(Math.random() * WIDTH),\r\n      Math.floor(Math.random() * HEIGHT)\r\n    );\r\n    nodes.push(node);\r\n    nodes2.push(node);\r\n  }\r\n}\r\n\r\n//calculating the force on each body\r\nconst theta = 0.45;\r\nconst k = 50;\r\nconst kSquare = Math.pow(k, 2);\r\nlet iterationCount = 2;\r\nconst count = async () => {\r\n  while (iterationCount > 0) {\r\n    await sleep(1000);\r\n    iterationCount--;\r\n    ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);\r\n    let boundary = new Rectangle(WIDTH / 2, HEIGHT / 2, WIDTH / 2, HEIGHT / 2);\r\n    qt = new Quadtree(boundary);\r\n    initializeNodesRandomly(1000);\r\n    console.time(\"brute force time \" + iterationCount);\r\n    for (let i = 0; i < nodes2.length; i++) {\r\n      nodes2[i].displacement = {\r\n        x: 0,\r\n        y: 0,\r\n      };\r\n      for (let j = 0; j < nodes2.length; j++) {\r\n        //check for if these two are connected or not with adjajency matrix\r\n        if (i != j) {\r\n          let displacement2 = calRepDisplacement(nodes2[i], nodes2[j], 1);\r\n          nodes2[i].displacement.x += displacement2.x;\r\n          nodes2[i].displacement.y += displacement2.y;\r\n        }\r\n      }\r\n    }\r\n    console.timeEnd(\"brute force time \" + iterationCount);\r\n\r\n    const BH = () => {\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        qt.insert(nodes[i]);\r\n      }\r\n      console.log(qt);\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        let node1 = nodes[i];\r\n        node1.displacement = {\r\n          x: 0,\r\n          y: 0,\r\n        };\r\n        let toVisit = [];\r\n        toVisit.push(qt);\r\n        while (toVisit.length > 0) {\r\n          let qd = toVisit.pop();\r\n          let mass = qd.mass;\r\n          //if it is empty box\r\n          if (mass == 0) continue;\r\n\r\n          let nodes = qd.nodes;\r\n          let CoM = qd.CoM;\r\n\r\n          if (mass == 1) {\r\n            // console.log(nodes[0]);\r\n            //calculate the force if it is not node1\r\n            let isNotSame = true;\r\n            if (nodes.length > 0) {\r\n              isNotSame = nodes[0].index != node1.index;\r\n            }\r\n            if (isNotSame && distance(node1, CoM) > 0.0001) {\r\n              let displacement = calRepDisplacement(node1, CoM, mass);\r\n              node1.displacement.x += displacement.x;\r\n              node1.displacement.y += displacement.y;\r\n            }\r\n            continue;\r\n          }\r\n          let boundary = qd.boundary;\r\n          let s = 2 * boundary.w;\r\n          let d = distance(node1, CoM);\r\n\r\n          //treat it as a single body\r\n          if (s / d < theta) {\r\n            let displacement = calRepDisplacement(node1, CoM, mass);\r\n            node1.displacement.x += displacement.x;\r\n            node1.displacement.y += displacement.y;\r\n            continue;\r\n          }\r\n\r\n          //otherwise\r\n          let NE = qd.NE;\r\n          let NW = qd.NW;\r\n          let SW = qd.SW;\r\n          let SE = qd.SE;\r\n\r\n          toVisit.push(NE, NW, SW, SE);\r\n        }\r\n      }\r\n    };\r\n\r\n    console.time(\"BH time\" + iterationCount);\r\n    BH();\r\n    console.timeEnd(\"BH time\" + iterationCount);\r\n  }\r\n};\r\n\r\nconsole.log(\"hi\");\r\ncount();"]}